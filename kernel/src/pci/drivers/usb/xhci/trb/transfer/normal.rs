//! The [`NormalTrb`] type

use x86_64::PhysAddr;

use super::super::TrbType;

/// The main payload data of a [`NormalTrb`].
///
/// This is either an address for data to be read from or written to, or it is 8 bytes of immediate data.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum NormalTrbData {
    /// The data should be read from or written to a memory buffer
    Address(PhysAddr),
    /// These 8 bytes are the data
    ImmediateData([u8; 8]),
}

/// The configuration data of a [`NormalTrb`]
#[bitfield(u32)]
pub struct NormalTrbConfig {
    /// For an OUT transfer, the number of bytes the controller will fetch from the [`Address`] in [`data`].
    /// If 0, the controller will execute a zero-length transaction.
    ///
    /// For an IN transfer, the number of bytes the OS expects to be written to the [`Address`] in [`data`]
    ///
    /// [`Address`]: NormalTrbData::Address
    /// [`data`]: NormalTrb::data
    /// [zero-length transaction]:
    #[bits(17)]
    transfer_length: u32,

    /// An indicator of the number of packets remaining in the TD.
    ///
    /// See the spec section [4.11.2.4] for how to calculate this value
    ///
    /// [4.11.2.4]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A225%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C610%2C0%5D
    #[bits(5)]
    td_size: u8,

    /// The index of the Interrupter that will receive events generated by this TRB
    #[bits(10)]
    interrupter_target: u16,
}

#[bitfield(u32)]
pub struct NormalTrbFlags {
    /// This bit is used to mark the Enqueue Pointer of the Transfer ring
    cycle: bool,

    /// If `true`, the controller shall fetch and evaluate the next TRB before saving the endpoint state (TODO: link)
    ///
    /// See the spec section [4.12.3] for more info.
    ///
    /// [4.12.3]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A257%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C694%2C0%5D
    evaluate_next_trb: bool,

    /// If `true` and a _Short Packet_ is encountered for this TRB
    /// (i.e., less than the amount specified in [`transfer_length`]), then a Transfer Event TRB shall be
    /// generated with its Completion Code set to Short Packet. The TRB Transfer Length field in the
    /// Transfer Event TRB shall reflect the residual number of bytes not transferred into the associated
    /// data buffer. In either case, when a Short Packet is encountered, the TRB shall be retired without
    /// error and the xHC shall advance to the next Transfer Descriptor (TD)
    ///
    /// TODO: So many links
    ///
    /// [`transfer_length`]: NormalTrbConfig::transfer_length
    interrupt_on_short_packet: bool,

    /// If `true`, the controller is allowed to set the [No Snoop] bit on PCIe transactions initiated by this TRB.
    ///
    /// [No Snoop]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A303%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C330%2C0%5D
    no_snoop: bool,

    /// Whether there are more TRBs in the TD after this one.
    ///
    /// This should be `true` for all TRBs in a TD except for the last one.
    chain: bool,

    /// Whether the controller should send a _Transfer Event_ when this TRB completes.
    ///
    /// This will also send and interrupt, unless [`block_event_interrupt`] is `true`.
    ///
    /// See the spec sections [4.10.4] and [4.17.5] for more info.
    ///
    /// [`block_event_interrupt`]: NormalTrbFlags::block_event_interrupt
    /// [4.10.4]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A214%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C442%2C0%5D
    /// [4.17.5]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A302%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C694%2C0%5D
    interrupt_on_completion: bool,

    /// Whether the [`data`] is immediate data rather than a pointer.
    ///
    /// This field shall not be `true` for IN TRBs.
    ///
    /// [`data`]: NormalTrb::data
    immediate_data: bool,

    #[bits(2)]
    _reserved: (),

    /// If this field and [`interrupt_on_completion`] are both `true`, the _Transfer Event_ will not assert an interrupt.
    ///
    /// [`interrupt_on_complete`]: NormalTrbFlags::interrupt_on_complete
    block_event_interrupt: bool,

    /// Should always be [`Normal`][TrbType::Normal]
    #[bits(6, default = TrbType::Normal)]
    trb_type: TrbType,

    #[bits(16)]
    _reserved: (),
}

/// A [normal TRB]
///
/// [normal TRB]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A472%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C391%2C0%5D
#[derive(Debug)]
pub struct NormalTrb {
    /// The TRB's data
    data: NormalTrbData,
    /// Configuration for the TRB
    config: NormalTrbConfig,
    /// The TRB flags
    flags: NormalTrbFlags,
}

impl NormalTrb {
    /// Converts the TRB to the data written to a TRB ring
    pub fn to_parts(&self, cycle: bool) -> [u32; 4] {
        let data = match self.data {
            NormalTrbData::Address(addr) => addr.as_u64(),
            NormalTrbData::ImmediateData(data) => u64::from_le_bytes(data), // TODO: check endianness
        };

        let config = self.config.into();
        let flags = self.flags.with_cycle(cycle).into();

        #[allow(clippy::cast_possible_truncation)]
        [data as u32, (data >> 32) as u32, config, flags]
    }

    /// The value of the chain bit
    pub fn chain(&self) -> bool {
        self.flags.chain()
    }
}
