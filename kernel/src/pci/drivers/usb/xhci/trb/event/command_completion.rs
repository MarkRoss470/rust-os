//! The [`CommandCompletionTrb`] type, as well as [`CompletionCode`]
//! and related [`CompletionError`] and [`CompletionCodeStopped`] types.

use x86_64::PhysAddr;

use crate::pci::drivers::usb::xhci::trb::TrbType;

#[bitfield(u32)]
pub struct CommandCompletionTrbFlags {
    pub cycle: bool,

    #[bits(9)]
    _reserved0: (),

    #[bits(6)]
    pub trb_type: TrbType,

    pub virtual_function_id: u8,
    pub slot_id: u8,
}

/// A completion code for a [`CommandCompletionTrb`] which is an error.
///
/// These codes are defined in the spec section [6.4.5]
///
/// [6.4.5]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A514%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C648%2C0%5D
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CompletionError {
    /// Indicates that the Host Controller is unable to keep up with the reception
    /// of incoming data (overrun) or is unable to supply data fast enough during
    /// transmission (underrun). Section 4.10.2.5 defines the requirements of the
    /// host controller when a Data Buffer Error occurs.
    DataBuffer,
    /// Asserted when “babbling” is detected during the transaction generated by this TRB.
    ///
    /// When a TD Babble condition occurs on non-Isoch endpoints it generates a Babble Detected Error and halts the
    /// endpoint. However for Isoch endpoints, a TD Babble condition generates an Isoch Buffer Overrun and does not
    /// halt the endpoint.
    BabbleDetected,
    /// Asserted in the case where the host did not receive a valid response from
    /// the device (Timeout, CRC, Bad PID, unexpected NYET, etc.).
    UsbTransaction,
    /// Asserted when a TRB parameter error condition (e.g., out of range or
    /// invalid parameter) is detected in a TRB.
    ///
    /// See the spec section [4.10.2.2] for examples.
    ///
    /// [4.10.2.2]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A203%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C223%2C0%5D
    Trb,
    /// Asserted when a Stall condition (e.g., a Stall PID received from a device) is
    /// detected for a TRB. Refer to the spec section [4.10.2.1] for more information on
    /// Stalls.
    ///
    /// This code also indicates that the USB device has an error that prevents it
    /// from completing a command issued through a Control endpoint.
    ///
    /// See the spec section 8.5.3.1 of the [USB2 spec] for more information.
    ///
    /// [4.10.2.1]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A202%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C401%2C0%5D
    /// [USB2 spec]: https://www.usb.org/document-library/usb-20-specification
    Stall,
    /// Asserted by a [`ConfigureEndpoint`] or an [`AddressDevice`] command
    /// Command if there are not adequate xHC resources available to
    /// successfully complete the command.
    ///
    /// See the spec sections [4.6.5] and [4.6.6] for more information.
    ///
    /// [`ConfigureEndpoint`]: super::super::CommandTrb::ConfigureEndpoint
    /// [`AddressDevice`]: super::super::CommandTrb::AddressDevice
    /// [4.6.5]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A117%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C169%2C0%5D
    /// [4.6.6]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A122%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C511%2C0%5D
    Resource,
    /// Asserted by a [`ConfigureEndpoint`] Command if periodic endpoints are
    /// declared and the xHC is not able to allocate the required Bandwidth.
    ///
    /// See the spec section [4.16] for more information.
    ///
    /// [`ConfigureEndpoint`]: super::super::CommandTrb::ConfigureEndpoint
    /// [4.16]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A290%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C555%2C0%5D
    Bandwidth,
    /// Asserted if a adding one more device would result in the host controller to
    /// exceed [`max_device_slots`] for this implementation.
    ///
    /// See the spec section [4.6.3] for more information.
    ///
    /// [`max_device_slots`]: super::super::super::registers::capability::StructuralParameters1::max_device_slots
    /// [4.6.3]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A114%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C224%2C0%5D
    NoSlotsAvailable,
    /// Asserted if an invalid Stream Context Type (SCT) value is detected.
    ///
    /// See the spec section [4.12.2.1] for more information.
    ///
    /// [4.12.2.1]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A255%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C694%2C0%5D
    InvalidStreamType,
    /// Asserted if a command is issued to a Device Slot that is in the Disabled
    /// state. The Slot ID is reported.
    SlotNotEnabled,
    /// Asserted if a doorbell is rung for an endpoint that is in the Disabled state.
    /// The Slot ID and error Endpoint ID are reported.
    ///
    /// See the spec section [4.7].
    ///
    /// [4.7]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A165%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C179%2C0%5D
    EndpointNotEnabled,
    /// Asserted if the number of bytes received was less than the TD Transfer Size.
    ShortPacket,
    /// Asserted in a [`Transfer`] Event TRB if the Transfer Ring is empty when an
    /// enabled Isoch endpoint is scheduled to transmit data.
    ///
    /// See the spec section [4.10.3.1].
    ///
    /// Note that the [`Transfer`] Event TRB Pointer field is not valid when this
    /// condition is indicated and should be ignored by software.
    ///
    /// [`Transfer`]: super::EventTrb::Transfer
    /// [4.10.3.1]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A211%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C389%2C0%5D
    RingUnderrun,
    /// Asserted in a [`Transfer`] Event TRB if the Transfer Ring is empty when an
    /// enabled Isoch endpoint is scheduled to receive data.
    ///
    /// See the spec section [4.10.3.1].
    ///
    /// Note that the [`Transfer`] Event TRB Pointer field is not valid when this
    /// condition is indicated and should be ignored by software.
    ///
    /// [4.10.3.1]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A211%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C389%2C0%5D
    /// [`Transfer`]: super::EventTrb::Transfer
    RingOverrun,
    /// Asserted by a [`ForceEvent`] command if the target VF’s Event Ring is full.
    ///
    /// See the spec section [4.9.4] for more information.
    ///
    /// Note that the [`Transfer`] Event TRB Pointer field is not valid when this error
    /// is indicated and should be ignored by software.
    ///
    /// [`ForceEvent`]: super::super::CommandTrb::ForceEvent
    /// [4.9.4]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A186%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C694%2C0%5D
    /// [`Transfer`]: super::EventTrb::Transfer
    VfEventRingFull,
    /// Asserted by a command if a Context parameter is invalid
    Parameter,
    /// Asserted during an Isoch transfer if the TD exceeds the bandwidth
    /// allocated to the endpoint.
    BandwidthOverrun,
    /// Asserted if a command is issued to transition from an illegal context state.
    ContextState,
    /// Asserted if the xHC was unable to complete a periodic data transfer
    /// associated within the ESIT, because it did not receive a `PING_RESPONSE`
    /// in time.
    ///
    /// See the spec section [4.23.5.2.1] for more information.
    ///
    /// [4.23.5.2.1]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A364%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C392%2C0%5D
    NoPingResponse,
    /// Asserted if the Event Ring is full, the xHC is unable to post an Event to the
    /// ring (see the spec section [4.9.4]). This error is reported in a Host Controller
    /// Event TRB.
    ///
    /// [4.9.4]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A186%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C694%2C0%5D
    EventRingFull,
    /// Asserted if the xHC detects a problem with a device that does not allow it
    /// to be successfully accessed. e.g. due to a device compliance or
    /// compatibility problem. This error may be returned by any command or
    /// transfer, and is fatal as far as the Slot is concerned. Software shall issue a
    /// [`DisableSlot`] Command to recover.
    ///
    /// [`DisableSlot`]: super::super::CommandTrb::DisableSlot
    IncompatibleDevice,
    /// Asserted if the xHC was unable to service a Isochronous endpoint within
    /// the Interval time (ESIT).
    ///
    /// See the spec sections [4.9.4] and [4.10.3.2] for more information.
    ///
    /// [4.9.4]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A186%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C694%2C0%5D
    /// [4.10.3.2]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A213%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C565%2C0%5D
    MissedService,
    /// Asserted by the [`EvaluateContext`] Command if the proposed Max Exit
    /// Latency would not allow the periodic endpoints of the Device Slot to be
    /// scheduled.
    ///
    /// See the spec sections [4.23.5.2.2] and [4.6.6.1].
    ///
    /// [`EvaluateContext`]: super::super::CommandTrb::EvaluateContext
    /// [4.23.5.2.2]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A365%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C622%2C0%5D
    /// [4.6.6.1]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A112%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C373%2C0%5D
    MaxExitLatencyTooLargeError,
    /// Asserted if the data buffer defined by an Isoch TD on an IN endpoint is
    /// less than the Max ESIT Payload in size and the device attempts to send
    /// more data than it can hold.
    ///
    /// See the spec sections [4.14.2.1.1] and [4.14.2.1.3].
    ///
    /// [4.14.2.1.1]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A269%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C668%2C0%5D
    /// [4.14.2.1.3]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A270%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C351%2C0%5D
    IsochBufferOverrun,
    /// Asserted if the xHC internal event overrun condition. If the condition is
    /// due to TD related events, then the endpoint shall be halted. The
    /// conditions that generate this error are xHC implementation specific.
    ///
    /// See the spec section [4.10.1].
    ///
    /// [4.10.1]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A196%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C498%2C0%5D
    EventLost,
    /// May be reported by an event when other error codes do not apply. The
    /// conditions that assert this condition code are xHC implementation
    /// specific.
    ///
    /// Refer to section [4.11.6] for more information.
    ///
    /// An Undefined Error shall be treated as a fatal error by software.
    ///
    /// [4.11.6]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A239%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C369%2C0%5D
    Undefined,
    /// Asserted if an invalid Stream ID is received.
    ///
    /// See the spec section [4.12.2.1] for more information.
    ///
    /// [4.12.2.1]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A255%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C694%2C0%5D
    InvalidStreamId,
    /// Asserted by a [`ConfigureEndpoint`] Command if periodic endpoints are
    /// declared and the xHC is not able to allocate the required Bandwidth due
    /// to a Secondary Bandwidth Domain.
    ///
    /// See the spec section [4.16] for more information.
    ///
    /// [`ConfigureEndpoint`]: super::super::CommandTrb::ConfigureEndpoint
    /// [4.16]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A290%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C555%2C0%5D
    SecondaryBandwidth,
    /// Asserted if an error is detected on a USB2 protocol endpoint for a split
    /// transaction.
    ///
    /// See the spec section [4.10.3.3].
    ///
    /// [4.10.3.3]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A214%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C694%2C0%5D
    SplitTransaction,

    /// The error is defined by the controller's manufacturer
    VendorDefined(u8),
}

/// A completion code indicating that a transaction was terminated
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CompletionCodeStopped {
    /// Asserted in a [`Transfer`] Event if the transfer was terminated by a  [`StopEndpoint`] Command.
    ///
    /// See the spec section [4.6.9] for more information.
    ///
    /// [4.6.9]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A140%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C694%2C0%5D
    /// [`Transfer`]: super::EventTrb::Transfer
    /// [`StopEndpoint`]: super::super::CommandTrb::StopEndpoint
    Stopped,
    /// Asserted in a [`Transfer`] Event if the transfer was terminated by a
    /// [`StopEndpoint`] Command and the [`Transfer`] Event TRB Transfer Length field is
    /// invalid.
    ///
    /// See the spec section [4.6.9] for more information.
    ///
    /// [`Transfer`]: super::EventTrb::Transfer
    /// [`StopEndpoint`]: super::super::CommandTrb::StopEndpoint
    /// [4.6.9]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A140%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C694%2C0%5D
    StoppedLengthInvalid,
    /// Asserted in a [`Transfer`] Event if the transfer was terminated by a
    /// [`StopEndpoint`] Command, and the transfer was stopped after Short Packet
    /// conditions were met, but before the end of the TD was reached. The
    /// [`Transfer`] Event TRB Transfer Length field shall contain the value of the
    /// EDTLA.
    ///
    /// See the spec section [4.6.9] for more information on the Stop Endpoint Command,
    /// section [4.10.1.1] for Short Transfer information, and section [4.11.5.2] for EDTLA information.
    ///
    /// [`Transfer`]: super::EventTrb::Transfer
    /// [`StopEndpoint`]: super::super::CommandTrb::StopEndpoint
    /// [4.6.9]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A140%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C694%2C0%5D
    /// [4.10.1.1]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A198%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C501%2C0%5D
    /// [4.11.5.2]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A237%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C436%2C0%5D
    StoppedShortPacket,
}

/// The completion code of a [`CommandCompletion`] TRB.
///
/// [`CommandCompletion`]: super::EventTrb::CommandCompletion
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CompletionCode {
    /// An invalid value - indicates that the controller has not set the completion code properly
    Invalid,
    /// The command succeeded
    Success,

    /// Asserted in a [`CommandCompletion`] Event due to a Command Stop (CS)
    /// operation.
    ///
    /// See the spec section [4.6] for more information.
    ///
    /// [`CommandCompletion`]: super::EventTrb::CommandCompletion
    /// [4.6]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A110%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C427%2C0%5D
    CommandRingStopped,
    /// Asserted in a [`CommandCompletion`] Event of an aborted command if the
    /// command was terminated by a Command Abort (CA) operation. Refer to
    /// section [4.6] for more information.
    ///
    /// [`CommandCompletion`]: super::EventTrb::CommandCompletion
    /// [4.6]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A110%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C427%2C0%5D
    CommandAborted,

    /// An error occurred while processing the TRB
    Error(CompletionError),
    /// A transaction was terminated
    Stopped(CompletionCodeStopped),

    /// Reserved codes
    Reserved(u8),
    /// Vendor-defined codes
    VendorDefined(u8),
}

impl CompletionCode {
    /// Constructs a [`CompletionCode`] from its bit representation
    const fn from_bits(bits: u8) -> Self {
        match bits {
            0 => Self::Invalid,
            1 => Self::Success,
            2 => Self::Error(CompletionError::DataBuffer),
            3 => Self::Error(CompletionError::BabbleDetected),
            4 => Self::Error(CompletionError::UsbTransaction),
            5 => Self::Error(CompletionError::Trb),
            6 => Self::Error(CompletionError::Stall),
            7 => Self::Error(CompletionError::Resource),
            8 => Self::Error(CompletionError::Bandwidth),
            9 => Self::Error(CompletionError::NoSlotsAvailable),
            10 => Self::Error(CompletionError::InvalidStreamType),
            11 => Self::Error(CompletionError::SlotNotEnabled),
            12 => Self::Error(CompletionError::EndpointNotEnabled),
            13 => Self::Error(CompletionError::ShortPacket),
            14 => Self::Error(CompletionError::RingUnderrun),
            15 => Self::Error(CompletionError::RingOverrun),
            16 => Self::Error(CompletionError::VfEventRingFull),
            17 => Self::Error(CompletionError::Parameter),
            18 => Self::Error(CompletionError::BandwidthOverrun),
            19 => Self::Error(CompletionError::ContextState),
            20 => Self::Error(CompletionError::NoPingResponse),
            21 => Self::Error(CompletionError::EventRingFull),
            22 => Self::Error(CompletionError::IncompatibleDevice),
            23 => Self::Error(CompletionError::MissedService),

            24 => Self::CommandRingStopped,
            25 => Self::CommandAborted,
            26 => Self::Stopped(CompletionCodeStopped::Stopped),
            27 => Self::Stopped(CompletionCodeStopped::StoppedLengthInvalid),
            28 => Self::Stopped(CompletionCodeStopped::StoppedShortPacket),

            29 => Self::Error(CompletionError::MaxExitLatencyTooLargeError),

            30 => Self::Reserved(30),

            31 => Self::Error(CompletionError::IsochBufferOverrun),
            32 => Self::Error(CompletionError::EventLost),
            33 => Self::Error(CompletionError::Undefined),
            34 => Self::Error(CompletionError::InvalidStreamId),
            35 => Self::Error(CompletionError::SecondaryBandwidth),
            36 => Self::Error(CompletionError::SplitTransaction),

            37..=191 => Self::Reserved(bits),
            192..=223 => Self::Error(CompletionError::VendorDefined(bits)),
            224..=255 => Self::VendorDefined(bits),
        }
    }
    
    /// Constructs a [`CompletionCode`] from its bit representation
    pub const fn new(bits: u8) -> Self {
        Self::from_bits(bits)
    }
}

/// A _Command Completion Event_ TRB. This is sent by the controller when it executes a [`CommandTrb`].
///
/// This has two uses:
/// * To inform the OS about errors or other conditions
/// * To inform the OS that it can write another TRB in the same place in the [`CommandTrbRing`]
///
/// See the spec section [6.4.2.2] for the definition of this structure.
///
/// [`CommandTrb`]: super::super::CommandTrb
/// [`CommandTrbRing`]: super::super::CommandTrbRing
/// [6.4.2.2]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A486%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C468%2C0%5D
#[derive(Debug, Clone, Copy)]
pub struct CommandCompletionTrb {
    /// The address of the [`CommandTrb`] this is in response to
    ///
    /// [`CommandTrb`]: super::super::CommandTrb
    pub command_trb_pointer: PhysAddr,

    /// An optional piece of data that the controller can give the OS about the execution of the command.
    /// This is specific to the type of [`CommandTrb`].
    ///
    /// This field is used in [`ConfigureEndpoint`] commands to hold the _Exit Latency Delta_ ([4.6.6.1]).
    ///
    /// [`CommandTrb`]: super::super::CommandTrb
    /// [`ConfigureEndpoint`]: super::super::CommandTrb::ConfigureEndpoint
    /// [4.6.6.1]: https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/extensible-host-controler-interface-usb-xhci.pdf#%5B%7B%22num%22%3A132%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C138%2C164%2C0%5D
    pub command_completion_parameter: u32,

    /// The success or error code of the TRB's execution
    pub completion_code: CompletionCode,

    /// The TRB's flags
    pub flags: CommandCompletionTrbFlags,
}

impl CommandCompletionTrb {
    /// Constructs a new [`CommandCompletionTrb`] from the data read from the event ring
    pub fn new(data: [u32; 4]) -> Self {
        let command_trb_pointer = (data[0] as u64) & !0b1111 | (data[1] as u64) << 32;
        let command_trb_pointer = PhysAddr::new(command_trb_pointer);

        let command_completion_parameter = data[2] & ((1 << 24) - 1);
        let completion_code = CompletionCode::from_bits((data[2] >> 24) as u8);

        let flags = CommandCompletionTrbFlags::from(data[3]);

        Self {
            command_trb_pointer,
            command_completion_parameter,
            completion_code,
            flags,
        }
    }
}
